# read() 함수 사용 연습하기

read() 함수에 대해 안다고 착각하고 파일 입출력을 다루려고 했더니 실제로 코드를 작성할 때 함수 활용을 못하겠다. read() 함수 자체에 대한 이해만 한다고 문제가 해결될 것 같지 않아 인프런에 있는 '리눅스 시스템 프로그램' 강의의 '파일 다루기 (low-level)'을 듣고 정리하고, 기본적인 저수준의 파일 입출력 함수를 직접 다뤄본 뒤 과제 코드를 작성해보기로 했다.

## 강의 노트 01 > 저수준 파일 열기/닫기, 스트림 포지션

* fopen과 open API의 차이점

	* fopen API : open API를 이용해서 libc 라이브러리에서 구현한 API

	* open API : low-level 수준의 API, 시스템 콜 => 사용하기는 조금 더 까다롭고 어려울 수 있지만 다양한 옵션 사용 가능

* open API의 두가지 함수 프로토 타입 (차이는 매개변수에 mode의 유무)

	* `int open(const char *pathname, int flags);`

	* `ìnt open(const char *pathname, int flags, mode_t mode);`

	* 매개변수

		* pathname : 파일 경로

		* flags : 접근 모드를 포함한 여러가지 플래그

		* mode : 파일 생성 시 설정할 권한 (flag 내에 파일을 생성하는 경우에만 사용 가능)

	* 반환값 (int 타입 / fopen의 반환값은 스트림 포인터였음)

		* 성공 : 열린 파일 디스크립터 (fd)

		* 실패 : -1

	* 플래그 값으로 자주 사용되는 것

		* 필수 옵션

			* O_RDONLY : 읽기 전용	

			* O_WRONLY : 쓰기 전용

			* O_RDWR : 읽기 + 쓰기
		                
		* 추가 옵션

			* O_CREAT : 파일이 존재하지 않을 경우 regular file 생성

			* O_NOFOLLOW : 파일이 심볼릭 링크일 경우 파일 열기 실패

			* O_TRUNC : regular file이 존재하는 경우 파일 사이즈를 0으로 만듦 (파일 저장 내용 전부 삭제 후 새로 열기)

			* O_APPEND : append mode로 열기 (파일 오프셋이 파일 끝에 위치, 오픈 이후 저장하는 데이터는 파일 끝에 위치함)

		* 플래그 사용 방법

			: 필수 옵션과 추가 옵션을 함께 사용할 경우 비트와이즈 OR 연산을 통해서 연산 설정 필요

			ex. `O_RDWR | O_CREAT` : 파일을 읽기와 쓰기가 모두 가능한 모드로 열되, 파일이 존재하지 않을 경우 파일을 생성해서 연다.

			* 비트와이즈 : 비트 단위로 수행되는 연산 (&, | ^, ~) -> 이진수 표현을 다룰 때 사용

				& 연산 : 두 비트가 모두 1인 경우 결과를 1로 -> 특정 비트를 0으로 설정하는데 사용

				| 연산 : 두 비트 중 하나가 1인 경우 결과를 1로 -> 특정 비트를 1로 설정하는데 사용

				^ 연산 : 두 비트가 서로 다른 경우 결과를 1로 -> 두 값이 서로 다를 때만 특정 동작 수행하는데 유용

				=> 비트와이즈 연산은 하드웨어 제어, 데이터 암호화, 네트워크 프로토콜 처리 등 다양한 분야에서 사용한다.

				=> 여러 플래그를 결합해 하나의 플래그를 만들 때 많이 사용한다.
		
		* 권한

			* ls -la를 살펴보면 세 그룹의 권한을 확인할 수 있다 => owner(파일 소유자), group(파일 소유자 그룹), other(소유자, 그룹 외 사람들 권한)

			* 파일에 설정할 수 있는 권한은 r(읽기), w(쓰기), x(실행)으로 총 세종류가 있다.

			* 소유자 권한 : S_IRWXU (모든 권한 부여, 7) | S_IRUSR (읽기 권한만 부여, 4) | S_IWUSR (쓰기 권한만 부여, 2) | S_IXUSR (실행 권한만 부여, 1)

			* 그룹의 권한 : S_IRWXG (모든 권한 부여, 7) | S_IRGRP (읽기 권한만 부여, 4) | S_IWGRP (쓰기 권한만 부여, 2) | S_IXGRP (실행 권한만 부여, 1)

			* 타인의 권한 : S_IRWXO (모든 권한 부여, 7) | S_IROTH (읽기 권한만 부여, 4) | S_IWOTH (쓰기 권한만 부여, 2) | S_IXOTH (실행 권한만 부여, 1)

			* 각 그룹의 권한은 심볼을 비트와이즈 OR 연산으로 연결해서 표현할 수도 있으나, 각각이 갖고 있는 8진수의 숫자를 조합해서도 부여할 수 있다.

* close API : open API를 이용해서 열어둔 파일의 파일 디스크립터를 닫을 때 사용

	* 프로토 타입 : `int close(int fd)`

	* 매개변수 = fd : 파일 디스크립터

	* 반환값

		* 성공 : 0

		* 실패 : -1

* lseek API : 파일 포지션을 변경할 때 사용

	* 프로토 타입 : `off_t lseek(int fd, off_t offset, int whence)``

	* 매개변수

		* fd : 파일 디스크립터

		* offset : 오프셋 값 (양수와 음수 모두 가능)

		* whence : 오프셋의 기준

			* SEEK_SET : 파일의 시작 기준

			* SEEK_END : 파일의 끝 기준

			* SEEK_CUR : 현재 파일 포지션의 기준

	* 반환값

		* 성공 : 완료 후 파일 포지션 (오프셋 값)

		* 실패 : -1

	* 오프셋

		: 일반적으로 위치나 거리를 나타내는데 사용 / CS에서는 특정 위치나 값으로부터의 상대적인 거리를 의미한다.

		* 오프셋이라는 개념은 주로 메모리나 파일 등의 데이터 구조에서 사용된다.

		* 파일 오프셋 : 파일 내의 특정 위치를 나타내는데 사용 -> 오프셋을 이용해 파일 읽기 쓰기 중 파일 내 원하는 위치로 이동 가능

	* libc 표준 라이브러리에서는 ftell() 과 같은 현재 오프셋을 가리키는 함수가 있으나, 저수준 시스템 호출에서는 동일한 역할을 하는 구분된 API가 없다.

		대신 lseek()을 사용해 설정할 수 있다 => `cur_offset = lseek(fd, 0, SEEK_CUR)` : 현재 값을 기준으로 (SEEK_CUR) 움직이지 않고 (0) 반환

## 강의 노트 02 > 저수준 파일 문자/문자열 읽고 쓰기

## 강의 노트 03 > 하드 링크와 소프트 링크

## 강의 노트 04 > 파일 속성
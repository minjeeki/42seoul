# Get Next Line

* [과제 원문 파일](./en.subject.pdf)

* [과제 관련 번역 파일 깃허브 링크](https://github.com/42seoul-translation/subject_ko/blob/master/get_next_line/get_next_line.ko.md)

* [get_next_line 작업 관련 노션 링크](https://bitter-cloth-1a0.notion.site/GetNextLine-80278d3c5a044d84ab107810a0123a71?pvs=4)

## 01 > 과제 목표

**파일 디스크립터로부터 개행으로 구분된 한줄을 받아와 읽고 반환하는 함수 만들기**

* 파일 디스크립터, 시스템 호출 함수(read)를 사용한 파일 내 한줄의 문장 읽는 함수 구현

* 정적 변수에 대한 이해

## 02 > 과제 설명

* 제출할 파일

	* [get_next_line.c](../get_next_line.c) : get_next_lie() 함수가 담겨 있는 파일

	* [get_next_line_utils.c](../get_next_line_utils.c) : 헬퍼 함수가 담겨 있는 파일

	* [get_next_line.h](../get_next_line.h) : 2개의 c언어 파일 내 함수들을 서로 연결해주는 헤더 파일

	* 그외 > [Makefile](../Makefile) : C언어 프로그램을 빌드하는데 사용되는 make 명령어의 설정 파일

* 함수 프로토 타입

	```C
	char *get_next_line(int fd);
	```

* 매개변수 : 읽어들일 파일의 디스크립터 (파일 서술자)

* 반환값

	* 정상 반환 : 읽어들인 문자열 한 줄 반환 (개행이 없는 경우가 아니라면 반환 문자열에는 \n이 포함되어야 함)

	* 에러 반환 (+ 읽어올 것이 더이상 없는 경우) : NULL 반환

* 사용 가능한 외부 함수

	* `<unistd.h>` 헤더 파일에 내장된 `read()`

	* `<stdlib.h>` 헤더 파일에 내장된 `malloc()`, `free()`

* 주의 사항

	* 컴파일 옵션에는 -D BUFFER_SIZE=42 가 반드시 있어야 한다. (이 때 BUFFER_SIZE 값이 1인 상황과 10000000인 경우도 생각해야 함)

	* 전체 파일을 읽은 후에 한줄씩 처리하는 것 안됨

	* libft 사용 및 lseek() 함수 사용 불가

	* 전역 변수 사용 불가

* 보너스 사항

	* 정적 변수를 한개만 사용해 get_next_line() 함수 개발하기

	* 여러개의 파일 디스크립터를 한번에 관리할 수 있는 함수 개발하기 (각 디스크립터 한줄씩 처리하면서 동작해야 함)


## 03 > 과제 필수 개념 조사

* 파일, 파일 시스템에 대한 기초적인 지식은 [파일, 파일 시스템, 파일 접근](./basic_of_file.md) 참고

### 0. 파일 입출력 함수

* 파일 입출력 함수, 표준 입출력 함수
	
	: 표준 입출력 함수 역시 내부적으로는 파일 입출력 함수이다.
		
	* 표준 입출력 함수 : stdout 포인터(콘솔의 출력 장치를 추상화한 파일)가 가리키는 파일에서 출력, stdin(입력 장치를 추상화한 파일)이 가리키는 파일에서 정보를 읽어오는 함수 => 입출력 대상이 장치 파일

	* 파일 입출력 함수 : 프로그램에서 연 파일(텍스트 또는 바이너리 파일)에 내용을 쓰거나 (입력), 읽는 (출력) 함수 => 입출력 대상이 텍스트 또는 바이너리 파일 (디스크에 존재하는 문자열을 출력 또는 디스크에 문자열을 기록)

* C언어에서 파일 입출력에 관련한 함수는 시스템 콜을 사용하는 방법과 표준 라이브러리 함수를 이용하는 방법이 있다.

	* [표준 라이브러리 함수를 이용한 파일 입출력](./file_io_by_library_func.md) : 정상 작동 시 파일 디스크립터를 반환한다.

	* [시스템 콜을 이용한 파일 입출력](./file_io_by_system_call.md) : 정상 작동 시 파일 포인터를 반환한다.

* read()와 fread()로 살펴보는 시스템 호출 함수와 라이브러리 함수의 차이점

	* 실행 위치
	
		* read() : 유닉스 및 유닉스 계열 운영체제에서 사용 (C라이브러리 의존 X), 커널에서 실행

		* fread() : <stdio.h> 헤더 파일에 정의, 사용자 공간에서 실행

	* 인자 및 반환 값

		* read() : 파일 디스크립터, 버퍼 포인터, 읽을 바이트 수 / 읽은 바이트 수 or -1 반환

		* fread() : 파일 포인터, 읽을 요소의 크기, 읽을 요소의 개수 및 버퍼 / 읽은 요소 수 or 오류 나타내는 값 반환

	* 에러 처리

		* read() : 직접 에러 코드 설정 필요

		* fread() : 표준 라이브러리 함수이기에 내부적으로 에러처리가 됨

	* 권한 및 접근성

		* read() : 운영체제의 권한 및 보안 정책을 따름. 특정 작업 수행을 위한 접근 권한이 필요할 수 있음

		* fread() : 프로세스가 일반적으로 접근할 수 있는 파일 및 자원을 대상으로 동작

	* 오버헤드

		* read() : 커널 모드로 전환되어 실행되기에 호출하는데 약간의 오버헤드가 있을 수 있음
		
			(시스템의 기능을 활용하기 위해 필요하나 프로세스 실행 시간에 부하 유발 및 시스템 자원 소비 등을 일으킬 수 있어 성능에 영향을 줌)

		* fread() : 사용자 공간에서 직접 실행되기에 오버 헤드가 적음

	* 사용 케이스

		* read() : 저수준의 운영체제 기능에 직접 접근할 때 사용, 특정 운영체제에 종속적일 수 있음

		* fread() : 이식성이 높고 사용자 친화적인 인터페이스를 제공함

### 1. 시스템 호출 파일 입출력 함수 read()

: 파일에서 데이터를 읽어 버퍼를 저장하는 시스템 호출 함수

* 프로토 타입

	```C
	ssize_t read(int fd, void *buf, size_t count);
	```

	* 인자

		* fd : 파일 디스크립터

		* buf : 데이터를 저장할 버퍼의 포인터

		* count : 읽을 바이트 수

	* 반환값

		* 성공 : 실제로 읽은 바이트 수

		* 실패 : -1 반환 & errno 변수에 오류 코드 설정

* ssize_t 자료형

	: 부호 있는 정수를 저장하는데 사용되는 데이터 형식

	* 시스템에 따라 처리할 수 있는 데이터의 크기가 달라지며, 일반적으로는 포인터와 동일한 크기를 가지며, 포인터의 크기와 동일하기에 주소 연산에 유용해 포인터와 ssize_t 사이의 변환이 자유롭다.

	* 시스템 호출 및 파일 입출력 등의 작업에서 사용된다 => 시스템 호출 함수 중에서는 오류나 특정 조건에서 음수값을 반환하기에 부호가 있는 정수인 unsigned int를 사용할 경우 사용자가 오류 처리하는 것이 더 어려울 수 있기에 ssize_t를 사용한다.

	* stddef.h 헤더파일에 정의되어 있다.

* [read() 함수 사용 연습하기](./practice_read_func.md)

### 2. 파일 디스크립터

: 컴퓨터 시스템에서 파일이나 기타 입출력 장치와 상호작용하기 위해 사용되는 숫자 식별자

* 각 파일이나 입출력 장치에 대해 정수 값으로 할당됨 (파일을 열거나 생성할 때 반환되는 정수가 파일 디스크립터)

* 파일 디스크립터를 이용해 시스템 호출 함수를 사용하면 파일 시스템의 파일에 대한 읽기, 쓰기, 닫기 등의 작업을 수행할 수 있음

### 3. 버퍼 사이즈

* read() 함수에서의 버퍼 : 읽어온 데이터를 임시적으로 저장하는 메모리 공간

	* 입출력 작업은 외부 장치와 상호작용을 해야 하기에 컴퓨터 내부에서만 동작하는 작업에 비해 상대적으로 오랜 시간이 걸린다.

		=> 입출력 작업의 효율성을 높이기 위해 버퍼를 사용해 데이터를 미리 읽거나 써 데이터 로드 또는 쓰는 대기 시간을 줄일 수 있다.

		=> 작은 단위의 입출력 작업의 경우 작업마다 시스템 호출을 할 경우 비교적 많은 오버헤드를 발생시키에 한번에 처리해 오버헤드를 최소화할 수 있다.

	* 버퍼를 사용하면 데이터를 비동기적으로 처리할 수 있어 (데이터를 버퍼에 쓴 후 다른 작업 수행 및 다른 작업 수행후 버퍼에서 데이터 읽기 가능) 입출력 작업과 다른 작업들 간에 효율적인 시간 분배가 가능하게 해준다.

	=> 입출력 작업의 성능 향상 및 데이터 처리 효율성 높이기 위해 사용

* 버퍼의 사이즈를 설정하는 것이 중요한 이유

	* 버퍼 사이즈가 작을 경우 작은 양의 데이터만 읽어오고 외부 장치에 요청을 여러번 보내야 하기에 시스템 호출이 늘어나고 오버헤드가 증가하게 된다.

	* 버퍼 사이즈가 클 경우 더 많은 메모리를 사용하게 되는데 이로 인한 시스템 자원 한계가 발생할 수 있다.

* get_next_line에서 버퍼 사이즈가 중요하게 작용하는 이유



### 4. 정적 변수 (static variables)

: 함수 또는 블록 내에서 선언되어 프로그램이 실행하는 동안 메모리의 데이터 영역에 저장되는 변수

* 특징

	* 유효 범위 및 접근 제어 : 선언된 특정 함수나 블록 내에서만 사용되며, 선언된 함수 내에서만 유효하고 함수 외부에서는 접근할 수 없다.

	* 메모리 유지성 : 프로그램이 종료될 때까지 메모리에 유지된다.

	* 초기화 : 함수가 호출될 때마다 초기화되지 않고, 한번 초기화되면 프로그램을 실행하는 동안 유지된다.

	=> 함수 호출 사이에 상태를 유지하고 데이터를 공유하는데 유용 & 메모리 사용을 최적화하고 데이터 은닉을 제공해 안전성을 높이는데도 사용함

* get_next_line에서 정적 변수를 사용해야 하는 이유

	: 파일 디스크립터와 같은 상태를 유지해야 하는 작업에서 유용하게(가독성 향상, 자원 관리 문제 방지) 사용함

	* 함수 호출 간에 상태를 쉽게 추적할 수 있기에 이전에 읽은 위치를 기억하거나 파일을 연 뒤 어디서부터 읽어야 하는지 추적하는 등의 작업에 사용할 경우 코드를 더 간단하게 작성할 수 있음

	* 정적 변수를 사용할 경우 파일 디스크립터나 다른 상태 정보를 여러 함수에서 공유하고 작업을 수행할 수 있어 각 함수가 올바르게 동작할 수 있게 한다.

	* 파일 디스크립터는 사용이 끝난 뒤 명시적으로 해제되어야 하는데 정적 변수를 사용하지 않을 경우 메모리 누수와 같은 문제가 발생할 수 있기에 함수 내부에서 상태를 유지하고 자원을 올바르게 관리하는데 필요하다.

### cf. 레퍼런스

* 블로그 > [C 파일 입출력: 시스템 콜 vs 라이브러리 함수](https://int-i.github.io/c/2020-04-19/c-file-io/)

* 책 > '독하게 시작하는 C 프로그래밍' 547 ~ 575pg 파일 입출력 파트

## 04 > 과제 코드 작성 전 로직 짜기

* 관건 1. 파일에서 한 줄만을 읽고 다시 그 파일 디스크립터에 해당하는 파일의 읽기 작업이 나왔을 때, 내가 어디까지 읽었는지를 어떻게 알 수 있는가?

	* 원래는 표준 라이브러리 함수의 fseek() 함수를 사용해서 읽은 범위에 대한 정보를 얻어왔으나 우리 과제에서는 사용 불가함

	* 파일을 읽는 동안 읽은 바이트 수나 읽은 줄 수를 세는 작업을 수행하고 적절한 변수에 저장되어야 한다.

	* 파일을 처리하는 함수가 파일 디스크립터와 읽은 바이트 수를 인자로 받아 직접 업데이트하거나 파일을 처리하는 구조체를 사용해 파일마다 상태를 유지하는 방법도 가능할 수 있다.

## 05 > 실제 프로그램 작성 중 발생한 이슈들

## 06 > 프로그램 테스트 방법 (테스트 프로그램, 테스트 코드)

* 테스트 코드 > [gnl_test.c](../gnl_test.c)

* 테스트 프로그램